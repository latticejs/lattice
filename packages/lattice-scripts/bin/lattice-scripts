#!/usr/bin/env node
'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var path = require('path');
var path__default = _interopDefault(path);
var rollup = require('rollup');
var resolve = _interopDefault(require('rollup-plugin-node-resolve'));
var commonjs = _interopDefault(require('rollup-plugin-commonjs'));
var babel = _interopDefault(require('rollup-plugin-babel'));
var replace = _interopDefault(require('rollup-plugin-replace'));
var minify = _interopDefault(require('rollup-plugin-babel-minify'));
var colors = _interopDefault(require('colors'));
var program = _interopDefault(require('commander'));

const globals = {
  react: 'React',
  'react-dom': 'ReactDOM',
  'prop-types': 'PropTypes',
  classnames: 'classnames'
};

const commonExternals = ['@babel/runtime/helpers', '@material-ui/core/'];

var build = async (input, { formats = ['cjs', 'esm', 'umd'], env = process.env.NODE_ENV }) => {
  const baseDir = process.cwd();
  let pkg;

  try {
    pkg = require(path.join(baseDir, 'package.json'));
  } catch (error) {
    throw Error(`No package.json file found on ${baseDir}`);
  }

  input = path.join(baseDir, input);
  const name = pkg.name.split('/').pop();
  const production = env === 'production';

  const dests = {
    umd: pkg.browser,
    cjs: pkg.main,
    esm: pkg.module
  };

  const allExternals = Object.keys(pkg.peerDependencies)
    .concat(Object.keys(pkg.dependencies))
    .concat(commonExternals);

  const external = id => allExternals.some(ex => id.startsWith(ex));

  const plugins = [
    babel({
      exclude: /node_modules/,
      runtimeHelpers: true
    }),

    resolve({
      jsnext: true,
      browser: true,
      customResolveOptions: {
        moduleDirectory: path.join(baseDir, 'src')
      }
    }),

    commonjs({
      include: /node_modules/,
      namedExports: {
        '@material-ui/core/styles': ['withStyles']
      }
    }),

    replace({ 'process.env.NODE_ENV': JSON.stringify(env) }),

    production && minify()
  ];

  const inputOptions = {
    input,
    external,
    plugins,
    treeshake: {
      pureExternalModules: true
    },
    onwarn: (warning, warn) => {
      if (['MISSING_GLOBAL_NAME', 'UNUSED_EXTERNAL_IMPORT'].includes(warning.code)) return;
      if (warning.code === 'NON_EXISTENT_EXPORT') throw new Error(warning.message);

      warn(warning);
    }
  };

  const outputOptions = (format, file) => ({
    format,
    file,
    name,
    globals,
    sourcemap: !production,
    exports: 'named'
  });

  const bundle = await rollup.rollup(inputOptions);
  const result = {};
  for (const format of formats) {
    result[format] = await bundle.write(outputOptions(format, dests[format]));
  }

  return result;
};

var registerBuild = program$$1 => {
  program$$1
    .command('build')
    .description('Build your source files into cjs, esm or umd formats.')
    .usage('[options] <input>')
    .option('-f, --formats <formats>', 'Output formats to build', (formats = ['umd', 'cjs', 'esm']) =>
      formats.split(',')
    )
    .option('-e, --env <environment>', 'Environment', 'development')
    .action(async (input, cmd = { formats: ['umd', 'cjs', 'esm'], env: 'development' }) => {
      if (!process.argv.slice(3).length) {
        program$$1.outputHelp(colors.red);
        process.exit(1);
      }

      try {
        const outputs = await build(input, { formats: cmd.formats, env: cmd.env });

        // console.log({ outputs });

        console.log(colors.green.bold('\n ðŸš€ Your bundle is ready! ðŸš€\n'));

        console.log(colors.underline('Generated files:'));

        for (const format in outputs) {
          if (outputs.hasOwnProperty(format)) {
            const { fileName } = outputs[format];
            console.log(colors.cyan(`> ${colors.bold(format)}: ${path__default.join(process.cwd(), fileName)}`));
          }
        }
      } catch (error) {
        console.error(colors.red(error));
        program$$1.outputHelp();
        process.exit(1);
      }
    });
};

var name = "@latticejs/lattice-scripts";
var version = "1.0.1-alpha.12";
var description = "Scripts for @latticejs/lattice packages";
var repository = "latticejs/lattice";
var license = "MIT";
var publishConfig = {
	access: "private"
};
var bin = "bin/lattice-scripts";
var main = "dist/lattice-scripts.cjs.js";
var scripts = {
	build: "rollup -c"
};
var dependencies = {
	commander: "^2.19.0",
	colors: "^1.3.2",
	rollup: "^0.66.6",
	"rollup-plugin-babel": "^4.0.3",
	"rollup-plugin-babel-minify": "^6.1.1",
	"rollup-plugin-commonjs": "^9.2.0",
	"rollup-plugin-hashbang": "^1.0.1",
	"rollup-plugin-json": "^3.1.0",
	"rollup-plugin-node-resolve": "^3.4.0",
	"rollup-plugin-replace": "^2.1.0"
};
var pkg = {
	name: name,
	version: version,
	description: description,
	repository: repository,
	license: license,
	publishConfig: publishConfig,
	"private": true,
	bin: bin,
	main: main,
	scripts: scripts,
	dependencies: dependencies
};

program
  .version(pkg.version)
  .usage('command')
  .description(pkg.description);

registerBuild(program);

program.parse(process.argv);
